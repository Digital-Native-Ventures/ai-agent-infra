#!/usr/bin/env bash
set -euo pipefail

# Extract issue ID from task description or argument
TASK="${TASK:-$1}"
ISSUE_ID=$(echo "$TASK" | grep -oE '#[0-9]+' | tr -d '#' | head -1)

if [[ -z "$ISSUE_ID" ]]; then
  echo "‚ùå No issue ID found in task: $TASK"
  exit 1
fi

echo "üîç Processing issue #$ISSUE_ID"

REPO="${GITHUB_REPOSITORY:-Digital-Native-Ventures/alfred-agent-platform-v2}"
BRANCH="impl/issue-$ISSUE_ID"
TMPDIR=$(mktemp -d)
trap "rm -rf $TMPDIR" EXIT

# 1Ô∏è‚É£ Fetch the approved AI-Spec from issue comments
echo "üì• Fetching AI-Spec from issue #$ISSUE_ID..."
AI_SPEC=$(gh issue view "$ISSUE_ID" --repo "$REPO" --json comments --jq '
  .comments[] | 
  select(.body | contains("### AI-Spec")) | 
  .body
' | tail -1)

if [[ -z "$AI_SPEC" ]]; then
  echo "‚ùå No AI-Spec found in issue #$ISSUE_ID comments"
  exit 1
fi

echo "‚úÖ Found AI-Spec"

# 2Ô∏è‚É£ Build Claude prompt files
cat >"$TMPDIR/system.txt" <<'SYS'
You are the Implementer-agent in the Alfred AI Dev workflow.
Generate production-ready code based on the provided AI-Spec.

For DB schema tasks, generate:
1. An Alembic migration file with proper revision ID
2. SQLAlchemy models with type hints
3. Pytest unit tests that verify table creation and constraints

Output a JSON object with this structure:
{
  "files": [
    {
      "path": "migrations/versions/YYYYMMDD_HHMMSS_description.py",
      "content": "full file content here"
    }
  ]
}

Rules:
- Use current date/time for migration filenames
- Include proper imports and docstrings
- No placeholders or TODOs
- Follow PEP8 and project conventions
- Return ONLY the JSON object, no other text
SYS

echo "$AI_SPEC" >"$TMPDIR/user.txt"

# 3Ô∏è‚É£ Call Claude API
echo "ü§ñ Calling Claude 4..."
curl -s -X POST https://api.anthropic.com/v1/messages \
  -H "x-api-key: $ANTHROPIC_API_KEY" \
  -H "anthropic-version: 2023-06-01" \
  -H "content-type: application/json" \
  -d @- <<EOF >"$TMPDIR/claude_response.json"
{
  "model": "claude-3-5-sonnet-20241022",
  "max_tokens": 8192,
  "temperature": 0.2,
  "system": $(cat "$TMPDIR/system.txt" | jq -Rs .),
  "messages": [{
    "role": "user",
    "content": $(cat "$TMPDIR/user.txt" | jq -Rs .)
  }]
}
EOF

# Check for API errors
if ! jq -e '.content[0].text' "$TMPDIR/claude_response.json" >/dev/null 2>&1; then
  echo "‚ùå Claude API call failed:"
  cat "$TMPDIR/claude_response.json"
  exit 1
fi

# 4Ô∏è‚É£ Extract files and write to working tree
echo "üìù Writing generated files..."
jq -r '.content[0].text' "$TMPDIR/claude_response.json" >"$TMPDIR/files.json"

# Validate JSON structure
if ! jq -e '.files' "$TMPDIR/files.json" >/dev/null 2>&1; then
  echo "‚ùå Invalid response format from Claude:"
  cat "$TMPDIR/files.json"
  exit 1
fi

# Write each file
jq -c '.files[]' "$TMPDIR/files.json" | while read -r file; do
  FILE_PATH=$(echo "$file" | jq -r '.path')
  FILE_CONTENT=$(echo "$file" | jq -r '.content')
  
  mkdir -p "$(dirname "$FILE_PATH")"
  echo "$FILE_CONTENT" >"$FILE_PATH"
  echo "  ‚úì Wrote $FILE_PATH"
done

# 5Ô∏è‚É£ Create branch and commit
echo "üåø Creating branch $BRANCH..."
git checkout -b "$BRANCH" 2>/dev/null || git checkout "$BRANCH"
git add -A
git commit -m "feat: implement AI-Spec for issue #$ISSUE_ID

- Generated by Implementer-agent (Claude 3.5 Sonnet)
- Based on approved AI-Spec from issue #$ISSUE_ID
- Includes migrations, models, and tests

Co-authored-by: Implementer Agent <implementer@alfred-ai.dev>"

# 6Ô∏è‚É£ Push to remote
echo "üì§ Pushing to origin..."
git push -u origin "$BRANCH" --force-with-lease

# 7Ô∏è‚É£ Create or update PR
echo "üîó Creating pull request..."
PR_BODY="## Automated Implementation

This PR implements the approved AI-Spec from issue #$ISSUE_ID.

### Generated Files
$(git diff main --name-only | sed 's/^/- /')

### Source
- Issue: #$ISSUE_ID
- AI-Spec: Approved by Architect
- Implementation: Claude 3.5 Sonnet

---
*Generated by Implementer-agent*"

if gh pr create \
  --repo "$REPO" \
  --title "feat: implement DB schema for issue #$ISSUE_ID" \
  --body "$PR_BODY" \
  --head "$BRANCH" \
  --base main \
  --label "ai-generated,needs-review" 2>/dev/null; then
  echo "‚úÖ Created new PR"
else
  # PR already exists, update it
  gh pr edit "$BRANCH" --body "$PR_BODY"
  echo "‚úÖ Updated existing PR"
fi

echo "üéâ Implementation complete!"